
Ellis Medicine
Plan
Track
Quality
Portfolio
Reports
User Actions
Time In Process


CURRENT TIP
CORE (CUSTOM)





CUSTOM HTML
CORE (CUSTOM)





CA Agile Central|About|Support|Legal
          
SOURCE CODE: CUSTOM HTML

<!DOCTYPE HTML>

<html>
    <head>
        <script type="text/javascript">
            var userConfig = {
                subTitle: 'Stories In-Progress to Accepted',
                debug: true,
                trace: true,
                daysToShow: 120,
                // asOf: "2012-10-15",  // Optional. Only supply if want a specific time frame. Do not send in new Date().toISOString().

                scopeField: "_ProjectHierarchy",  // Supports Iteration, Release, Tags, Project, _ProjectHierarchy, _ItemHierarchy
                scopeValue: 'scope',

                statePredicate: {ScheduleState:{$lt:"Accepted", $gte:"In-Progress"}},
                currentStatePredicate: {ScheduleState:{$gte:"Accepted"}},
                type: 'HierarchicalRequirement',
                leafOnly: true,
                showTheseFieldsInToolTip: [ // Will automatically show ObjectID and Work Days In State
                  'Name',
                  {field: 'PlanEstimate', as: "Plan Estimate"}
                ],
                radiusField: {field: 'PlanEstimate', f: function(value){
                  if (isNaN(value)) {
                    return 5
                  } else {
                    return Math.pow(value, 0.6) + 5
                  }
                }},
                workDayStartOn: {hour: 9},
                workDayEndBefore: {hour: 17},
                // deriveFieldsOnSnapshotsConfig:
                // holidays: (unless we pull them from some data model in Rally)
                // workDays: (if you want to override the default pulling from WorkspaceConfiguration)
            }

/*
            // Feature Aging
            userConfig.subTitle = 'Features In Dev and less than 100% done'
            userConfig.daysToShow = 365
            userConfig.statePredicate = {"State":"In Dev", "PercentDoneByStoryCount":{$lt:1,$gt:0}}
            userConfig.currentStatePredicate = {ScheduleState:{$gt:"In Dev"}}
            userConfig.type = 'PortfolioItem/Feature'
            userConfig.leafOnly = false
            userConfig.showTheseFieldsInToolTip = [
              'Name',
              {field: 'LeafStoryCount', as: 'Leaf Story Count'},
              {field: "PercentDoneByStoryCount", as: 'Percent Done By Story Count', f: function(value) {
                return Math.floor(value * 100 + 0.5).toString() + '%';
              }}
            ]
            userConfig.radiusField = {field: 'LeafStoryCount', f: function(value){
              return Math.pow(value, 0.6) + 5
            }}
*/

        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Time In Process (TIP) Chart</title>

        <!-- HighCharts -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/3.0.10/highcharts.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/3.0.10/modules/exporting.src.js"></script>

        <!-- Lumenize -->
        <script type="text/javascript" src="https://storage.googleapis.com/versions.lumenize.com/v0.6.11/Lumenize-min.js"></script>

        <!-- rally_analytics -->
        
<script type="text/javascript">
// Generated by CoffeeScript 1.6.3
(function() {
  var AnalyticsQuery, AtAnalyticsQuery, BetweenAnalyticsQuery, GuidedAnalyticsQuery, Time, TimeInStateAnalyticsQuery, TransitionsAnalyticsQuery, lumenize, root, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/Lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils, Time = lumenize.Time;

  if ((utils != null ? utils.type : void 0) == null) {
    utils = {};
    utils.type = (function() {
      var classToType, name, _i, _len, _ref;
      classToType = {};
      _ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        classToType["[object " + name + "]"] = name.toLowerCase();
      }
      return function(obj) {
        var strType;
        strType = Object.prototype.toString.call(obj);
        return classToType[strType] || "object";
      };
    })();
  }

  root = this;

  AnalyticsQuery = (function() {
    /*
    This is the base class for all analytics query classes. For the most part, you are better off using
    one of the sub-classes but if you want more direct access, you can use this class as follows.
    
    ## Usage ##
    
    First, you need to "require" the desired analytics query class(es). In these examples, we're going to require a mock
    for the XMLHttpResponse Object but you will simply pass in the browser's XMHttpRequest Object (or 
    the equivalent from node-XMLHttpRequest if running on node.js)
    
        {XHRMock} = require('../../mock/XHRMock')
        rally_analytics = require('../')      
    
    Then, you need to set the config Object.
    
        config =
          'X-RallyIntegrationName': 'My Chart'
          'X-RallyIntegrationVendor': 'My Company'
          'X-RallyIntegrationVersion': '0.1.0'
          username: null  # if running in browser, will prompt
          password: null  # if running in Node.js will look for RALLY_USER/RALLY_PASSWORD environment variables
          workspaceOID: 12345
          additionalHeaders: [ 
            someHeader: 'Some Value'
          ]
    Which you can then use when instantiating a query.
    
        query = new rally_analytics.AnalyticsQuery(config, 'hello')
        query.XHRClass = XHRMock  # Not required to hit actual Rally Analytics API
    
    Then you must set the query. `find` is required but you can also specify sort, fields, etc. Notice how you can chain these calls.
    
        query.find({Project: 1234, Tag: 'Expedited', _At: '2012-01-01'}).fields(['ScheduleState'])
      
    Of course you need to have a callback.
    
        callback = () ->
          console.log(this.allResults.length)  # will spit back 5 from our XHRMock
        # 5
    
    Finally, call getPage()
    
        query.getAll(callback)
        
    ## Properties you can inspect or set ##
    
    * **username** default null
    * **password** default null
    * **protocol** default "https"
    * **server** default "rally1.rallydev.com"
    * **service** default "analytics"
    * **version** defaults to latest current version
    * **endpoint** defaults to "artifact/snapshot/query.js"
    * **XHRClass** defaults to the local context XMLHttpResquest. Set to mock for testing.
    
    ## Properties you should only inspect ##
    
    Note, the signature of the callback is callback(snapshots, startOn, endBefore, this). On the last page, endBefore will
    be the ETLDate. For earlier pages, it will be the _ValidFrom of the last row in lastPageResults, which is why the
    sort order must be {_ValidFrom: 1}. startOn will be the @upToDate value, so be sure to set it before calling getPage() for the
    first time. It will update it after that first call to getPage().
    
    The last parameter allows you to inspect the contents of this object. It has these potentially interesting properties.
    
    * **upToDate** the endBefore of the prior call or as set when calling the constructor
    * **ETLDate** the ETLDate of the response in the first page
    * **lastResponseText** the string containing the most recent response/page
    * **lastResponse** the parsed JSON Object of the most recent response/page
    * **lastPageResults** the Results from the most recent page
    * **allResults** the Results from all pages concatenated together
    * **lastPageMeta** the meta data included at the top of the most recent page
    * **allMeta** the meta data from all pages concatentated together including errors and warnings
    */

    function AnalyticsQuery(config, upToDate) {
      var XMLHttpRequest, addRequiredHeader, key, os, platform, value, _ref, _ref1, _ref2, _ref3;
      this.upToDate = upToDate;
      this._gotResponse = __bind(this._gotResponse, this);
      this._debug = false;
      if ((typeof process !== "undefined" && process !== null) && (typeof window === "undefined" || window === null)) {
        XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
      } else if (root.XMLHttpRequest != null) {
        XMLHttpRequest = root.XMLHttpRequest;
      }
      this.XHRClass = XMLHttpRequest;
      this._xhr = null;
      this._find = null;
      this._fields = [];
      this._sort = {
        _ValidFrom: 1
      };
      this._startIndex = 0;
      this._pageSize = 10000000;
      this._callback = null;
      this.headers = {};
      this.headers['X-RallyIntegrationLibrary'] = 'rally_analytics-0.1.0';
      if (typeof navigator !== "undefined" && navigator !== null) {
        platform = navigator.appName + ' ' + navigator.appVersion;
        os = navigator.platform;
      } else if (typeof process !== "undefined" && process !== null) {
        platform = 'Node.js (or some other non-browser) ' + process.version;
        os = process.platform;
      }
      this.headers['X-RallyIntegrationPlatform'] = platform;
      this.headers['X-RallyIntegrationOS'] = os;
      _ref = config.additionalHeaders;
      for (key in _ref) {
        value = _ref[key];
        this.headers[key] = value;
      }
      addRequiredHeader = function(headers, key) {
        if (config[key] != null) {
          return headers[key] = config[key];
        } else {
          throw new Error("Must include config[" + key + "] header when instantiating this rally_analytics.AnalyticsQuery object");
        }
      };
      addRequiredHeader(this.headers, 'X-RallyIntegrationName');
      addRequiredHeader(this.headers, 'X-RallyIntegrationVendor');
      addRequiredHeader(this.headers, 'X-RallyIntegrationVersion');
      if (config.workspaceOID != null) {
        this.workspaceOID = config.workspaceOID;
      } else if (typeof process !== "undefined" && process !== null ? (_ref1 = process.env) != null ? _ref1.RALLY_WORKSPACE : void 0 : void 0) {
        this.workspaceOID = process.env.RALLY_WORKSPACE;
      } else {
        throw new Error('Must provide a config.workspaceOID or set environment variable RALLY_WORKSPACE');
      }
      if (config.username != null) {
        this.username = config.username;
      } else if (typeof process !== "undefined" && process !== null ? (_ref2 = process.env) != null ? _ref2.RALLY_USER : void 0 : void 0) {
        this.username = process.env.RALLY_USER;
      } else {
        this.username = void 0;
      }
      if (config.password != null) {
        this.password = config.password;
      } else if (typeof process !== "undefined" && process !== null ? (_ref3 = process.env) != null ? _ref3.RALLY_PASSWORD : void 0 : void 0) {
        this.password = process.env.RALLY_PASSWORD;
      } else {
        this.password = void 0;
      }
      this.protocol = "https";
      this.server = "rally1.rallydev.com";
      this.service = "analytics";
      this.version = "v2.0";
      this.endpoint = "artifact/snapshot/query.js";
      this.virgin = true;
      this._hasMorePages = true;
      this._firstPage = true;
      this.ETLDate = null;
      this.lastResponseText = '';
      this.lastResponse = {};
      this.lastPageResults = [];
      this.allResults = [];
      this.lastPageMeta = {};
      this.allMeta = [];
    }

    AnalyticsQuery.prototype.resetFind = function() {
      return this._find = null;
    };

    AnalyticsQuery.prototype.find = function(_find) {
      this._find = _find;
      return this;
    };

    AnalyticsQuery.prototype.sort = function() {
      throw new Error('Sort must be {_ValidFrom: 1}.');
    };

    AnalyticsQuery.prototype._setSort = function(_sort) {
      this._sort = _sort;
      return this;
    };

    AnalyticsQuery.prototype.fields = function(additionalFields) {
      var field, key, temp, value, _i, _len, _ref;
      if (utils.type(additionalFields) === 'array') {
        this._fields = this._fields.concat(additionalFields);
      } else if (utils.type(additionalFields) === 'object') {
        if (utils.type(this._fields) === 'array') {
          temp = {};
          _ref = this._fields;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            field = _ref[_i];
            temp[field] = 1;
          }
          this._fields = temp;
        }
        for (key in additionalFields) {
          value = additionalFields[key];
          this._fields[key] = value;
        }
      } else {
        throw new Error("Don't know what to do. additionalFields is type " + (utils.type(additionalFields)) + " and @_fields it type " + (utils.type(this._fields)) + ".");
      }
      return this;
    };

    AnalyticsQuery.prototype.hydrate = function(_hydrate) {
      this._hydrate = _hydrate;
      return this;
    };

    AnalyticsQuery.prototype.start = function(_startIndex) {
      this._startIndex = _startIndex;
      return this;
    };

    AnalyticsQuery.prototype.startIndex = function(_startIndex) {
      this._startIndex = _startIndex;
      return this;
    };

    AnalyticsQuery.prototype.pagesize = function(_pageSize) {
      this._pageSize = _pageSize;
      return this;
    };

    AnalyticsQuery.prototype.pageSize = function(_pageSize) {
      this._pageSize = _pageSize;
      return this;
    };

    AnalyticsQuery.prototype.auth = function(username, password) {
      this.username = username;
      this.password = password;
      return this;
    };

    AnalyticsQuery.prototype.debug = function() {
      this._debug = true;
      return this;
    };

    AnalyticsQuery.prototype.getBaseURL = function() {
      return this.protocol + '://' + [this.server, this.service, this.version, 'service/rally/workspace', this.workspaceOID, this.endpoint].join('/');
    };

    AnalyticsQuery.prototype.getQueryString = function() {
      var findString, queryArray;
      findString = JSON.stringify(this._find);
      if ((this._find != null) && findString.length > 2) {
        queryArray = [];
        queryArray.push('find=' + findString);
        if (this._sort != null) {
          queryArray.push('sort=' + JSON.stringify(this._sort));
        }
        if (this._fields != null) {
          if (this._fields[0] === true) {
            queryArray.push('fields=true');
          } else if (this._fields.length > 0 || utils.type(this._fields) === 'object') {
            if (!(__indexOf.call(this._fields, '_ValidFrom') >= 0 || this._fields.hasOwnProperty('_ValidFrom'))) {
              if (utils.type(this._fields) === 'object') {
                this._fields._ValidFrom = 1;
              } else if (utils.type(this._fields) === 'array') {
                this._fields.push('_ValidFrom');
              } else {
                throw new Error("@_fields is unexpected type " + (utils.type(this._fields)));
              }
            }
            queryArray.push('fields=' + JSON.stringify(this._fields));
          }
        }
        if (this._hydrate != null) {
          queryArray.push('hydrate=' + JSON.stringify(this._hydrate));
        }
        queryArray.push('start=' + this._startIndex);
        queryArray.push('pagesize=' + this._pageSize);
        return queryArray.join('&');
      } else {
        throw new Error('find clause not set');
      }
    };

    AnalyticsQuery.prototype.getURL = function() {
      var url;
      url = this.getBaseURL() + '?' + this.getQueryString();
      if (this._debug) {
        console.log('\nfind: ', this._find);
        console.log('\nurl:');
        console.log(url);
      }
      return encodeURI(url);
    };

    AnalyticsQuery.prototype.getAll = function(callback) {
      if (this.virgin) {
        this.allCallback = callback;
        this.virgin = false;
        this.upToDate = '2011-12-01T00:00:00.000Z';
      }
      if (this.hasMorePages()) {
        return this.getPage(this.getAll);
      } else {
        return this.allCallback(this);
      }
    };

    AnalyticsQuery.prototype.hasMorePages = function() {
      return this._hasMorePages;
    };

    AnalyticsQuery.prototype.getPage = function(_callback) {
      var key, value, _ref;
      this._callback = _callback;
      if (this._find == null) {
        throw new Error('Must set find clause before calling getPage');
      }
      if (this.XHRClass == null) {
        throw new Error('Must set XHRClass');
      }
      if (!this._hasMorePages) {
        throw new Error('All pages retrieved. Inspect AnalyticsQuery.allResults and AnalyticsQuery.allMeta for results.');
      }
      if (this.upToDate == null) {
        throw new Error('Must set property upToDate before calling getPage');
      }
      this._xhr = new this.XHRClass();
      this._xhr.onreadystatechange = this._gotResponse;
      this._xhr.open('GET', this.getURL(), true, this.username, this.password);
      _ref = this.headers;
      for (key in _ref) {
        value = _ref[key];
        this._xhr.setRequestHeader(key, value);
      }
      this._xhr.send();
      return this;
    };

    AnalyticsQuery.prototype._gotResponse = function() {
      var key, newFind, o, results, startOn, value, _i, _len, _ref;
      if (this._debug) {
        console.log('\nreadyState: ', this._xhr.readyState);
      }
      if (this._xhr.readyState === 4) {
        this.lastResponseText = this._xhr.responseText;
        if (this._debug) {
          console.log('Last response text length: ', this.lastResponseText.length);
        }
        this.lastResponse = JSON.parse(this.lastResponseText);
        if (this._debug) {
          console.log('\nresponse headers:\n');
          console.log(this._xhr.getAllResponseHeaders());
          console.log('\nstatus: ', this._xhr.status);
          if (typeof this.lastResponse === 'string') {
            console.log('\nlastResponseText: ', this.lastResponseText);
          } else {
            console.log('\nlastResponseJSON: ', this.lastResponse);
          }
        }
        if (this.lastResponse.Errors.length > 0) {
          console.log('Errors\n' + JSON.stringify(this.lastResponse.Errors));
          return this._callback(this.lastPageResults, startOn, this.upToDate, this);
        } else {
          if (this._firstPage) {
            this._firstPage = false;
            this.allResults = [];
            this.allMeta = [];
            this.ETLDate = this.lastResponse.ETLDate;
            this._pageSize = this.lastResponse.PageSize;
            newFind = {
              '$and': [
                this._find, {
                  '_ValidFrom': {
                    '$lte': this.ETLDate
                  }
                }
              ]
            };
            this._find = newFind;
          } else {
            if (this.lastResponse.PageSize !== this._pageSize) {
              throw new Error('Pagesize changed after first page which is unexpected.');
            }
          }
          startOn = this.upToDate;
          if (this.lastResponse.Results.length + this.lastResponse.StartIndex >= this.lastResponse.TotalResultCount) {
            this._hasMorePages = false;
            this.upToDate = this.ETLDate;
          } else {
            this._hasMorePages = true;
            this.upToDate = this.lastResponse.Results[this.lastResponse.Results.length - 1]._ValidFrom;
          }
          this.lastPageResults = [];
          results = this.lastResponse.Results;
          if (this._debug) {
            console.log('Length of results before @upToDate filtering: ', results.length);
          }
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            o = results[_i];
            if (o._ValidFrom !== this.upToDate) {
              this.lastPageResults.push(o);
            }
          }
          if (this._debug) {
            console.log('Length of results after @upToDate filtering: ', this.lastPageResults.length);
          }
          this._startIndex += this.lastPageResults.length;
          this.allResults = this.allResults.concat(this.lastPageResults);
          this.lastPageMeta = {};
          _ref = this.lastResponse;
          for (key in _ref) {
            value = _ref[key];
            if (key !== 'Results') {
              this.lastPageMeta[key] = value;
            }
          }
          this.allMeta.push(this.lastPageMeta);
          return this._callback(this.lastPageResults, startOn, this.upToDate, this);
        }
      }
    };

    return AnalyticsQuery;

  })();

  GuidedAnalyticsQuery = (function(_super) {
    __extends(GuidedAnalyticsQuery, _super);

    /*
    To help you write performant queries against the non-traditional data model of Rally's Analytics engine, we provide a guided mode 
    for composing queries. Like the raw AnalyticsQuery, you start by creating a GuidedAnalyticsQuery Object. 
    
        query = new rally_analytics.GuidedAnalyticsQuery(config)
        query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
    
    **Scope**
    
    Then you must specify at least one highly selective criteria using the scope method:
    
        query.scope('Project', 1234) # or [1234, 5678]
        query.scope('_ProjectHierarchy', 1234) # or [1234, 5678], also accepts 'ProjectHierarchy'
        query.scope('Iteration', 1234) # or [1234, 5678]
        query.scope('Release', 1234) # or [1234, 5678]
        query.scope('_ItemHierarchy', 1234) # also accepts 'ItemHierarchy'
        query.scope('Tags', 'Top 10') # or ['Top 10', 'Expedite'], also accepts Tag
        
    The 'ProjectHierarchy' scope is not necessarily highly selective. So you should make sure that you
    either have some other criteria or that you don't have too many Projects in scope beneith the specified Project(s).
    
    Alternatively, you can specify your scope in one big object:
    
        query.scope({
          _ProjectHierarchy: 1234,
          Iteration: [1234, 5678], 
        })
        
    **Type**
    
    You can optionally limit your query to one or more work item types. Defaults to all types.
    
        query.type('Defect') # alteratively ['Defect', 'HierarchicalRequirement']
        
    Note, a change is expected to be made such that the Analytics API will require ObjectIDs of the types.
    When that happens, we may update this REST toolkit to hide that from you but you'll need to update
    to the latest version.
    
    **Leaf Nodes Only**  
    
    You can also specify that you only want leaf nodes to be returned by the query.
    
        query.leafOnly()
        
    It will expand to a clause like: 
        
        {
          '$or': [
            {_TypeHierarchy: "HierarchicalRequirement", Children: null},
            {_TypeHierarchy:"PortfolioItem", Children: null, UserStories: null}
          ]
        }
    
    **Additional Criteria**
    
    You can also specify additional critaria. This can be useful for defining "sub-classes" of work items.
        
        query.additionalCriteria({Environment: 'Production'})
        
    **Chaining**
    
    Chaining is supported, so you could say:
    
        query = new rally_analytics.GuidedAnalyticsQuery(config)
        query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
        query.scope('_ProjectHierarchy', 1234)
             .type('HierarchicalRequirement')
             .leafOnly()
             .additionalCriteria({Blocked: true})
             
        query.find()
        console.log(JSON.stringify(query._find, undefined, 2))
        # {
        #   "$and": [
        #     {
        #       "_ProjectHierarchy": 1234
        #     },
        #     {
        #       "_TypeHierarchy": "HierarchicalRequirement"
        #     },
        #     {
        #       "$or": [
        #         {
        #           "_TypeHierarchy": -51038,
        #           "Children": null
        #         },
        #         {
        #           "_TypeHierarchy": -51078,
        #           "Children": null,
        #           "UserStories": null
        #         },
        #         {
        #           "_TypeHierarchy": {
        #             "$nin": [
        #               -51038,
        #               -51078
        #             ]
        #           }
        #         }
        #       ]
        #     },
        #     {
        #       "Blocked": true
        #     }
        #   ]
        # }
    */


    function GuidedAnalyticsQuery(config, upToDate) {
      GuidedAnalyticsQuery.__super__.constructor.call(this, config, upToDate);
      this._scope = {};
      this._type = null;
      this._additionalCriteria = [];
      if (upToDate != null) {
        this._additionalCriteria.push({
          "_ValidTo": {
            $gt: upToDate
          }
        });
      }
    }

    GuidedAnalyticsQuery.prototype.generateFind = function() {
      var c, compoundArray, _i, _len, _ref, _ref1;
      compoundArray = [];
      if (JSON.stringify(this._scope).length > 2) {
        compoundArray.push(this._scope);
      } else {
        throw new Error('Must set scope first.');
      }
      if (this._type != null) {
        compoundArray.push(this._type);
      }
      _ref = this._additionalCriteria;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        compoundArray.push(c);
      }
      if ((0 < (_ref1 = compoundArray.length) && _ref1 < 2)) {
        return compoundArray[0];
      } else {
        return {
          '$and': compoundArray
        };
      }
    };

    GuidedAnalyticsQuery.prototype.find = function() {
      if (arguments.length > 0) {
        throw new Error('Do not call find() directly to set query. Use scope(), type(), and additionalCriteria()');
      }
      GuidedAnalyticsQuery.__super__.find.call(this, this.generateFind());
      return this;
    };

    GuidedAnalyticsQuery.prototype.resetScope = function() {
      return this._scope = {};
    };

    GuidedAnalyticsQuery.prototype.scope = function(key, value) {
      var addToScope, k, v,
        _this = this;
      addToScope = function(k, v) {
        var okKeys;
        if (k === 'ItemHierarchy') {
          k = '_ItemHierarchy';
        }
        if (k === 'Tag') {
          k = 'Tags';
        }
        if (k === 'ProjectHierarchy') {
          k = '_ProjectHierarchy';
        }
        okKeys = ['Project', '_ProjectHierarchy', 'Iteration', 'Release', 'Tags', 'Tag', '_ItemHierarchy'];
        if (__indexOf.call(okKeys, k) < 0) {
          throw new Error("Key for scope() call must be one of " + okKeys);
        }
        if (utils.type(v) === 'array') {
          return _this._scope[k] = {
            '$in': v
          };
        } else {
          return _this._scope[k] = v;
        }
      };
      if (utils.type(key) === 'object') {
        for (k in key) {
          v = key[k];
          addToScope(k, v);
        }
      } else if (arguments.length === 2) {
        addToScope(key, value);
      } else {
        throw new Error('Must provide an Object in first parameter or two parameters (key, value).');
      }
      return this;
    };

    GuidedAnalyticsQuery.prototype.resetType = function() {
      return this._type = null;
    };

    GuidedAnalyticsQuery.prototype.type = function(type) {
      if (utils.type(type) === 'array') {
        this._type = {
          '_TypeHierarchy': {
            '$in': type
          }
        };
      } else {
        this._type = {
          '_TypeHierarchy': type
        };
      }
      return this;
    };

    GuidedAnalyticsQuery.prototype.resetAdditionalCriteria = function() {
      return this._additionalCriteria = [];
    };

    GuidedAnalyticsQuery.prototype.additionalCriteria = function(criteria) {
      this._additionalCriteria.push(criteria);
      return this;
    };

    GuidedAnalyticsQuery.prototype.leafOnly = function() {
      this.additionalCriteria({
        '$or': [
          {
            _TypeHierarchy: -51038,
            Children: null
          }, {
            _TypeHierarchy: -51078,
            Children: null,
            UserStories: null
          }, {
            _TypeHierarchy: {
              $nin: [-51038, -51078]
            }
          }
        ]
      });
      return this;
    };

    GuidedAnalyticsQuery.prototype.getPage = function(callback) {
      this.find();
      return GuidedAnalyticsQuery.__super__.getPage.call(this, callback);
    };

    return GuidedAnalyticsQuery;

  })(AnalyticsQuery);

  AtAnalyticsQuery = (function(_super) {
    __extends(AtAnalyticsQuery, _super);

    /*
    This pattern will tell you what a set of Artfacts looked like at particular moments in time
      
        query = new rally_analytics.AtAnalyticsQuery(config, 'hello', '2012-01-01T12:34:56.789Z')
        query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
        
    It will expand to a query like this:
        
        query.scope('_ProjectHierarchy', 1234)
        query.find()
        console.log(JSON.stringify(query._find, undefined, 2))
        # {
        #   "$and": [
        #     {
        #       "_ProjectHierarchy": 1234
        #     },
        #     {
        #       "__At": "2012-01-01T12:34:56.789Z"
        #     }
        #   ]
        # }
    */


    function AtAnalyticsQuery(config, upToDate, zuluDateString) {
      var key, o;
      AtAnalyticsQuery.__super__.constructor.call(this, config, upToDate);
      if (zuluDateString == null) {
        throw new Error('Must provide a zuluDateString when instantiating an AtAnalyticsQuery.');
      }
      o = {};
      key = String.fromCharCode(95) + "_At";
      o[key] = zuluDateString;
      this._additionalCriteria.push(o);
    }

    return AtAnalyticsQuery;

  })(GuidedAnalyticsQuery);

  BetweenAnalyticsQuery = (function(_super) {
    __extends(BetweenAnalyticsQuery, _super);

    /*
    This pattern will return all of the snapshots active in a particular timebox. The results are in the form expected by the 
    Lumenize function `snapshotArray_To_AtArray`, which will tell you what each work item looked like at a provided list of
    datetimes. This is the current recommended approach for most time-series charts. The burncalculator and cfdcalculator
    use this approach. Note: the 'AtArray' approach will supercede this for time-series charts at some point in the future.
      
        query = new rally_analytics.BetweenAnalyticsQuery(config, '2012-01-01T12:34:56.789Z', '2012-01-10T12:34:56.789Z')
        query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
    
    It will expand to a query like this:
    
        query.scope('_ProjectHierarchy', 1234)
        query.find()
        console.log(JSON.stringify(query._find, undefined, 2))
        # {
        #   "$and": [
        #     {
        #       "_ProjectHierarchy": 1234
        #     },
        #     {
        #       "_ValidFrom": {
        #         "$lt": "2012-01-10T12:34:56.789Z"
        #       }, 
        #       "_ValidTo": {
        #         "$gt": "2012-01-01T12:34:56.789Z"
        #       }
        #     }
        #   ]
        # }
    */


    function BetweenAnalyticsQuery(config, startOn, endBefore) {
      var criteria;
      BetweenAnalyticsQuery.__super__.constructor.call(this, config, startOn);
      if (!((startOn != null) && (endBefore != null))) {
        throw new Error('Must provide two zulu data strings when instantiating a BetweenAnalyticsQuery.');
      }
      criteria = {
        "_ValidFrom": {
          $lt: endBefore
        },
        "_ValidTo": {
          $gt: startOn
        }
      };
      this._additionalCriteria.push(criteria);
    }

    return BetweenAnalyticsQuery;

  })(GuidedAnalyticsQuery);

  TimeInStateAnalyticsQuery = (function(_super) {
    __extends(TimeInStateAnalyticsQuery, _super);

    /*
    This pattern will only return snapshots where the specified clause is true.
    This is useful for Cycle Time calculations as well as calculating Flow Efficiency or Blocked Time.
    
        query = new rally_analytics.TimeInStateAnalyticsQuery(config, 'hello', {KanbanState: {$gte: 'In Dev', $lt: 'Accepted'}})
        query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
    */


    function TimeInStateAnalyticsQuery(config, upToDate, predicate) {
      TimeInStateAnalyticsQuery.__super__.constructor.call(this, config, upToDate);
      if (predicate == null) {
        throw new Error('Must provide a predicate when instantiating a TimeInStateAnalyticsQuery.');
      }
      this._additionalCriteria.push(predicate);
      this.fields(['ObjectID', '_ValidFrom', '_ValidTo']);
    }

    return TimeInStateAnalyticsQuery;

  })(GuidedAnalyticsQuery);

  TransitionsAnalyticsQuery = (function(_super) {
    __extends(TransitionsAnalyticsQuery, _super);

    /*
    This pattern will return the snapshots where the _PreviousValue matches the first query clause parameter and the "current"
    value matches the second query clause parameter. In other words, it finds particular transitions. It is useful for 
    Throughput/Velocity calculations. 
    
    !TODO: Indent below to make sure it works and add example
    query = new TransitionsAnalyticsQuery(config,
      {ScheduleState: {$lt: 'Accepted'}}, 
      {ScheduleState: {$gte: 'Accepted'}}
    )
    query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
    
    
    The first predicate is actually converted such that any non-operator key is prepended with "_PreviousValues.". In the example
    above, "{ScheduleState: {$lt: 'Accepted'}}" becomes "{'_PreviousValues.ScheduleState': {$lt: 'Accepted'}}". So this will return
    the snapshots that made this particular transition from before state to after state.
    
    Note, you should also run the query swapping the two predicates and subtract the two calculations before reporting a Thoughput or 
    Velocity result. Without doing so, any story that crosses the boudary multiple times would get double, triple, etc. counted.
    
    In a future version, you may be able to specify aggregation functions ($count, $sum, $push, etc.) on a particular field when 
    making this query, because when you use this pattern, you are usually interested in the sum or count and not the actual snapshots.
    In the mean time, if you are only interested in the count, simply specify pagesize of 1 and inspect the TotalResultCount in the top
    section of the response.
    
    There is a good reason that Throughput and Velocity are defined with two predicates rather than just specifying the line to the left
    of "Accepted". Let's say, work is not really "Accepted" until the Ready flag is checked. You could write that query like so:
    
    !TODO: Indent below to make sure it works and add example
    query = new rally_analytics.TransitionsAnalyticsQuery(config,
      {$or: [{KanbanState: {$lt: 'Accepted'}}, {KanbanState: 'Accepted', Ready: false}]}, 
      {$or: [{KanbanState: 'Accepted', Ready: true}, {KanbanState: {$gt: 'Accepted'}}]}
    )
    query.XHRClass = XHRMock  # Not required to hit real Rally Analytics API
        
    It will expand to a query like this:
    
    !TODO: Indent below to make sure it works and add example
    query.scope('_ProjectHierarchy', 1234)
    query.find()
    console.log(JSON.stringify(query._find, undefined, 2))
    #
    */


    function TransitionsAnalyticsQuery(config, upToDate, predicate) {
      TransitionsAnalyticsQuery.__super__.constructor.call(this, config, upToDate);
      if (predicate == null) {
        throw new Error('Must provide a predicate when instantiating a TimeInStateAnalyticsQuery.');
      }
      this._additionalCriteria.push(predicate);
      this._additionalCriteria.push({
        "_ValidFrom": {
          $gte: upToDate
        }
      });
      this.fields(['ObjectID', '_ValidFrom', '_ValidTo']);
    }

    return TransitionsAnalyticsQuery;

  })(GuidedAnalyticsQuery);

  root.AnalyticsQuery = AnalyticsQuery;

  root.GuidedAnalyticsQuery = GuidedAnalyticsQuery;

  root.AtAnalyticsQuery = AtAnalyticsQuery;

  root.BetweenAnalyticsQuery = BetweenAnalyticsQuery;

  root.TimeInStateAnalyticsQuery = TimeInStateAnalyticsQuery;

  root.TransitionsAnalyticsQuery = TransitionsAnalyticsQuery;

}).call(this);

</script>

        <!-- md5 -->
        
<script type="text/javascript">
(function() {
/* md5.js - MD5 Message-Digest
 * Copyright (C) 1999,2002 Masanao Izumo <iz@onicos.co.jp>
 * Version: 2.0.0
 * LastModified: May 13 2002
 *
 * This program is free software.  You can redistribute it and/or modify
 * it without any warranty.  This library calculates the MD5 based on RFC1321.
 * See RFC1321 for more information and algorism.
 */

/* Interface:
 * md5_128bits = MD5_hash(data);
 * md5_hexstr = MD5_hexhash(data);
 */

/* ChangeLog
 * 2002/05/13: Version 2.0.0 released
 * NOTICE: API is changed.
 * 2002/04/15: Bug fix about MD5 length.
 */


//    md5_T[i] = parseInt(Math.abs(Math.sin(i)) * 4294967296.0);
var MD5_T = new Array(0x00000000, 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391);

var MD5_round1 = new Array(new Array(0, 7, 1), new Array(1, 12, 2), new Array(2, 17, 3), new Array(3, 22, 4), new Array(4, 7, 5), new Array(5, 12, 6), new Array(6, 17, 7), new Array(7, 22, 8), new Array(8, 7, 9), new Array(9, 12, 10), new Array(10, 17, 11), new Array(11, 22, 12), new Array(12, 7, 13), new Array(13, 12, 14), new Array(14, 17, 15), new Array(15, 22, 16));

var MD5_round2 = new Array(new Array(1, 5, 17), new Array(6, 9, 18), new Array(11, 14, 19), new Array(0, 20, 20), new Array(5, 5, 21), new Array(10, 9, 22), new Array(15, 14, 23), new Array(4, 20, 24), new Array(9, 5, 25), new Array(14, 9, 26), new Array(3, 14, 27), new Array(8, 20, 28), new Array(13, 5, 29), new Array(2, 9, 30), new Array(7, 14, 31), new Array(12, 20, 32));

var MD5_round3 = new Array(new Array(5, 4, 33), new Array(8, 11, 34), new Array(11, 16, 35), new Array(14, 23, 36), new Array(1, 4, 37), new Array(4, 11, 38), new Array(7, 16, 39), new Array(10, 23, 40), new Array(13, 4, 41), new Array(0, 11, 42), new Array(3, 16, 43), new Array(6, 23, 44), new Array(9, 4, 45), new Array(12, 11, 46), new Array(15, 16, 47), new Array(2, 23, 48));

var MD5_round4 = new Array(new Array(0, 6, 49), new Array(7, 10, 50), new Array(14, 15, 51), new Array(5, 21, 52), new Array(12, 6, 53), new Array(3, 10, 54), new Array(10, 15, 55), new Array(1, 21, 56), new Array(8, 6, 57), new Array(15, 10, 58), new Array(6, 15, 59), new Array(13, 21, 60), new Array(4, 6, 61), new Array(11, 10, 62), new Array(2, 15, 63), new Array(9, 21, 64));

function MD5_F(x, y, z) {
    return (x & y) | (~x & z);
}

function MD5_G(x, y, z) {
    return (x & z) | (y & ~z);
}

function MD5_H(x, y, z) {
    return x ^ y ^ z;
}

function MD5_I(x, y, z) {
    return y ^ (x | ~z);
}

var MD5_round = new Array(new Array(MD5_F, MD5_round1), new Array(MD5_G, MD5_round2), new Array(MD5_H, MD5_round3), new Array(MD5_I, MD5_round4));

function MD5_pack(n32) {
    return String.fromCharCode(n32 & 0xff) + String.fromCharCode((n32 >>> 8) & 0xff) + String.fromCharCode((n32 >>> 16) & 0xff) + String.fromCharCode((n32 >>> 24) & 0xff);
}

function MD5_unpack(s4) {
    return s4.charCodeAt(0) | (s4.charCodeAt(1) << 8) | (s4.charCodeAt(2) << 16) | (s4.charCodeAt(3) << 24);
}

function MD5_number(n) {
    while (n < 0)
        n += 4294967296;
    while (n > 4294967295)
        n -= 4294967296;
    return n;
}

function MD5_apply_round(x, s, f, abcd, r) {
    var a, b, c, d;
    var kk, ss, ii;
    var t, u;

    a = abcd[0];
    b = abcd[1];
    c = abcd[2];
    d = abcd[3];
    kk = r[0];
    ss = r[1];
    ii = r[2];

    u = f(s[b], s[c], s[d]);
    t = s[a] + u + x[kk] + MD5_T[ii];
    t = MD5_number(t);
    t = ((t << ss) | (t >>> (32 - ss)));
    t += s[b];
    s[a] = MD5_number(t);
}

function MD5_hash(data) {
    var abcd, x, state, s;
    var len, index, padLen, f, r;
    var i, j, k;
    var tmp;

    state = new Array(0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476);
    len = data.length;
    index = len & 0x3f;
    padLen = (index < 56) ? (56 - index) : (120 - index);
    if (padLen > 0) {
        data += "\x80";
        for (i = 0; i < padLen - 1; i++)
            data += "\x00";
    }
    data += MD5_pack(len * 8);
    data += MD5_pack(0);
    len += padLen + 8;
    abcd = new Array(0, 1, 2, 3);
    x = new Array(16);
    s = new Array(4);

    for (k = 0; k < len; k += 64) {
        for (i = 0, j = k; i < 16; i++, j += 4) {
            x[i] = data.charCodeAt(j) | (data.charCodeAt(j + 1) << 8) | (data.charCodeAt(j + 2) << 16) | (data.charCodeAt(j + 3) << 24);
        }
        for (i = 0; i < 4; i++)
            s[i] = state[i];
        for (i = 0; i < 4; i++) {
            f = MD5_round[i][0];
            r = MD5_round[i][1];
            for (j = 0; j < 16; j++) {
                MD5_apply_round(x, s, f, abcd, r[j]);
                tmp = abcd[0];
                abcd[0] = abcd[3];
                abcd[3] = abcd[2];
                abcd[2] = abcd[1];
                abcd[1] = tmp;
            }
        }

        for (i = 0; i < 4; i++) {
            state[i] += s[i];
            state[i] = MD5_number(state[i]);
        }
    }

    return MD5_pack(state[0]) + MD5_pack(state[1]) + MD5_pack(state[2]) + MD5_pack(state[3]);
}

function MD5_hexhash(data) {
    var i, out, c;
    var bit128;

    bit128 = MD5_hash(data);
    out = "";
    for (i = 0; i < 16; i++) {
        c = bit128.charCodeAt(i);
        out += "0123456789abcdef".charAt((c >> 4) & 0xf);
        out += "0123456789abcdef".charAt(c & 0xf);
    }
    return out;
}

this.md5 = MD5_hexhash;

}).call(this);
</script>

        <!-- my visualizer for this chart (optional) -->
        
<script type="text/javascript">
// Generated by CoffeeScript 1.6.3
/*
The general structure of an incrementally update-able visualization follows these steps:

1. Gather the parameters you'll need to specify the visualization
   a. Gather some info from Rally's standard WSAPI
   b. Gather some info from the user.

2. Create a hash from info from above to be used as the key for cache lookup.

3. Restore the cached calculation using LocalCache.

4. Render the cached calculation. Leave space for updates on the x-axis. Show spinners for missing parts.

5. Query the Lookback API for the incremental "snapshots" not found in the cache.
   Get one page's worth of updates. Maybe 10,000 snapshots max?

6. Update the calculation/manipulation/aggregation of the snapshot data.

7. Update the chart.

8. If there are still more pages of snapshots to update repeat starting at step 5.
*/


(function() {
  var Time, VisualizerBase, lumenize, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/Lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils, Time = lumenize.Time;

  VisualizerBase = (function() {
    /*
    @class ChartVisualizerBase
      This is intended to the be the base class for ChartVisualizers. It assumes a template method pattern where the parts
      of the algorithm that have to do with saving to and restoring from the LocalCache (using localStorage API) and
      providing events for config changes or data updates.
    
      You must override these methods:
        * initialize() - set @LumenizeCalculatorClass (implements Lumenize.iCalculator)
    
      You may wish to override:
        * deriveFields(snapshots)
    
    @cfg {Number} [refreshIntervalMilliseconds = 30 * 60 * 1000] Defaults to 30 minutes
    
    @property {Object} userConfig This is whatever the users passes in under the @userConfig parameter in the constructor. It is useful for creating the cache hash. The contents of this will be visualizer specific
    
    @property {Object} config Starts with all the values in userConfig but more may be added
    @property {Number} [config.refreshIntervalMilliseconds = 5 * 60 * 1000] The chart will automatically refresh after this many milliseconds
    @property {Object} [config.deriveFieldsConfig] If you include this, it will pass it into Lumenize.deriveFields as the config Object every time it gets new snapshots to process.
    @property {Boolean} [config.debug = false]
    @property {Object} config.lumenizeCalculatorConfig The config that will be passed to the Lumenize calculator upon instantiation. Do not put x-axis range info in here.
    
    @property {Object} projectAndWorkspaceScope
    @property {Number} projectAndWorkspaceScope.workspaceOID
    @property {Boolean} projectAndWorkspaceScope.projectScopingUp
    @property {Boolean} projectAndWorkspaceScope.projectScopingDown
    @property {Number} projectAndWorkspaceScope.projectOID
    
    @property {Object} workspaceConfiguration Has whatever fields come from Rally but WorkDays and TimeZone (note Caps) are often used by calculators
    
    @property {Lumenize.iCalculator} LumenizeCalculatorClass Must be set; typically in your initialize() method
    
    @property {Object} visualizationData This is where you store the data that you want to communicate to your visualizations.
      It will be passed into createVisualizationCB.
    
    @property {iAnalyticsQuery} analyticsQuery Instantiate this in your onNewDataAvailable() method.
    
    @property {String} upToDateISOString A ISOString (e.g. '2012-01-01T12:34:56.789Z') indicating the last moment that this chart is
      up to date. You should not set this but you can read from it. It will be set when new snapshots are added or it's
      restored from the cache.
    @readonly
    */

    /*
    Sequence diagram below can be edited here: http://www.asciiflow.com/#Draw2041780197906655348/1887977824
     +----------------------+ +-----------------------+ +---------------------+ +--------------------+ +-------------------+ +-----------------------+ +-------------------+ +---------------------+ +---------------+
     |initialize and before | |onConfigOrScopeUpdated | |createVisualization  | |onNewDataAvailable  | |onSnapshotsReceived| |deriveFieldsOnSnapshots| |updateCalculator   | |updateVisualization  | |newDataExpected|
     |----------------------| |-----------------------| |---------------------| |--------------------| |-------------------| |-----------------------| |-------------------| |---------------------| |---------------|
     |@userConfig           | |@lumenizeCalculator    | |@visualizationData   | |@upToDateISOString  | |@upToDateISOString | |snapshots              | |@lumenizeCalculator| |@visualizationData   | |               |
     |@config               | |@upToDateISOString     | | via call to         | | = '2011-12-01...'  | | = endBefore       | |                       | |@cache             | | via call to         | |               |
     |@cache                | | (null if not restored)| | @updateVisualizatio-| | if null            | |@fetchPending      | |                       | |                   | | @updateVisualizatio-| |               |
     |@createVisualizationCB| |@fetchPending = true   | | nData()             | |@analyticsQuery     | |                   | |                       | |                   | | nData()             | |               |
     |                      | |                       | |                     | |@fetchPending = true| |                   | |                       | |                   | |                     | |               |
     +----------------------+ +-----------------------+ +---------------------+ +--------------------+ +-------------------+ +-----------------------+ +-------------------+ +---------------------+ +---------------+
           |                            |                           |                  |                        |                       |                     |                        |                    |
           +--------------------------->|                           |                  |                        |                       |                     |                        |                    |
           |                            +-------------------------->|                  |                        |                       |                     |                        |                    |
           |                            |                           +----------------->|                        |                       |                     |                        |                    |
           |                            |                           |                  +----------------------->|                       |                     |                        |                    |
           |                            |                           |                  |                        +---------------------->|                     |                        |                    |
           |                            |                           |                  |                        |                       +-------------------->|                        |                    |
           |                            |                           |                  |                        |                       |                     +----------------------->|                    |
           |                            |                           |                  |                        |                       |                     |                        +------------------->|
           |                            |                           |                  |                        |                       |                     |                        |                    |
           |                            |                           |                  |<------------------------------- @timeoutHandle = setTimeout(@onNewDataAvailable, delay) ---------------------------+<-+
           |                            |                           |                  |                        |                       |                     |                        |                    |  |
           |                            |                           |                  +----------------------->|                       |                     |                        |                    |  |
           |                            |                           |                  |                        +---------------------->|                     |                        |                    |  |
           |                            |                           |                  |                        |                       +-------------------->|                        |                    |  |
           |                            |                           |                  |                        |                       |                     +----------------------->|                    |  |
           |                            |                           |                  |                        |                       |                     |                        +------------------->+--+
           |                            |                           |                  |                        |                       |                     |                        |                    |
    */

    function VisualizerBase(visualizations, userConfig, createVisualizationCB) {
      this.visualizations = visualizations;
      this.userConfig = userConfig;
      this.createVisualizationCB = createVisualizationCB;
      this.onSnapshotsReceieved = __bind(this.onSnapshotsReceieved, this);
      /*
      You should not have a constructor for the sub-class. Rather, put your code in initialize(). If for some crazy
      reason you really want a constructor, make sure it looks like this:
      ```
      constructor: (myCustomArgument, remainingArguments...) ->
        # Any code you want to execute before initialize(). Use myCustomArgument.
        super(remainingArguments...)
        # Any code you want to execute after initialize(). Use myCustomArgument.
      ```
      */

      this.config = utils.clone(this.userConfig);
      if (this.config.trace) {
        console.log('in VisualizerBase.constructor');
      }
      if (this.config.debug == null) {
        this.config.debug = false;
      }
      this.getProjectAndWorkspaceScope();
    }

    VisualizerBase.prototype.getProjectAndWorkspaceScope = function() {
      var projectOID, projectOIDsInScope, projectScopingDown, projectScopingUp, scope, workspaceOID, _callback,
        _this = this;
      if (this.config.trace) {
        console.log('in VisualizerBase.getProjectAndWorkspaceScope');
      }
      if (top === self) {
        workspaceOID = 41529001;
        projectScopingUp = false;
        projectScopingDown = true;
        projectOID = 81147451;
        projectOIDsInScope = [projectOID];
      } else {
        workspaceOID = __WORKSPACE_OID__;
        projectScopingUp = __PROJECT_SCOPING_UP__;
        projectScopingDown = __PROJECT_SCOPING_DOWN__;
        projectOID = __PROJECT_OID__;
        projectOIDsInScope = [__PROJECT_OIDS_IN_SCOPE__];
      }
      scope = {
        workspaceOID: workspaceOID,
        projectScopingUp: projectScopingUp,
        projectScopingDown: projectScopingDown,
        projectOID: projectOID,
        projectOIDsInScope: projectOIDsInScope
      };
      _callback = function(projectAndWorkspaceScope) {
        _this.projectAndWorkspaceScope = projectAndWorkspaceScope;
        return _this.getWorkspaceConfiguration();
      };
      return _callback(scope);
    };

    VisualizerBase.prototype.getWorkspaceConfiguration = function() {
      var workspaceConfiguration, _callback,
        _this = this;
      if (this.config.trace) {
        console.log('in VisualizerBase.getWorkspaceConfiguration');
      }
      workspaceConfiguration = {
        DateFormat: 'MM/dd/yyyy',
        DateTimeFormat: 'MM/dd/yyyy hh:mm:ss a',
        IterationEstimateUnitName: 'Points',
        ReleaseEstimateUnitName: 'Points',
        TaskUnitName: 'Hours',
        TimeTrackerEnabled: true,
        TimeZone: 'America/Denver',
        WorkDays: 'Monday,Tuesday,Wednesday,Thursday,Friday'
      };
      _callback = function(workspaceConfiguration) {
        _this.workspaceConfiguration = workspaceConfiguration;
        _this.initialize();
        return _this.onConfigOrScopeUpdated();
      };
      return _callback(workspaceConfiguration);
    };

    VisualizerBase.prototype.onConfigOrScopeUpdated = function() {
      var savedState;
      if (this.config.trace) {
        console.log('in VisualizerBase.onConfigOrScopeUpdated');
      }
      savedState = void 0;
      if (savedState != null) {
        if (this.config.debug) {
          console.log('Found a saved state in cache. Restoring from savedState. Size:', JSON.stringify(savedState).length);
          console.log(savedState);
        }
        this.lumenizeCalculator = this.LumenizeCalculatorClass.newFromSavedState(savedState);
        this.upToDateISOString = this.lumenizeCalculator.upToDateISOString;
      } else {
        if (this.config.debug) {
          console.log('Did not find a saved state in cache. Calculating from scratch.');
        }
        this.lumenizeCalculator = new this.LumenizeCalculatorClass(this.config.lumenizeCalculatorConfig);
        this.upToDateISOString = null;
      }
      this.fetchPending = true;
      this.createVisualization();
      this.dirty = false;
      return this.onNewDataAvailable();
    };

    VisualizerBase.prototype.getCurrentState = function() {
      var fields, queryConfig, scopeValue, _callback, _ref,
        _this = this;
      if (this.config.trace) {
        console.log('in VisualizerBase.getCurrentState');
      }
      _callback = function(queryHandle) {
        var r;
        console.log(queryHandle);
        _this.currentState = queryHandle.allResults;
        _this.currentObjectIDs = (function() {
          var _i, _len, _ref, _results;
          _ref = this.currentState;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            r = _ref[_i];
            _results.push(r.ObjectID);
          }
          return _results;
        }).call(_this);
        return _this.onNewDataAvailable();
      };
      queryConfig = {
        'X-RallyIntegrationName': 'Burn Chart (prototype)',
        'X-RallyIntegrationVendor': 'Rally Red Pill',
        'X-RallyIntegrationVersion': '0.2.0',
        workspaceOID: this.projectAndWorkspaceScope.workspaceOID
      };
      this.analyticsQuery = new GuidedAnalyticsQuery(queryConfig);
      if (this.config.scopeValue === 'scope') {
        if (this.projectAndWorkspaceScope.projectScopingUp) {
          if (this.config.debug) {
            console.log('Project scoping up. OIDs in scope: ', this.projectAndWorkspaceScope.projectOIDsInScope);
          }
          this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOIDsInScope);
        } else if (this.projectAndWorkspaceScope.projectScopingDown) {
          if (this.config.debug) {
            console.log('Project scoping down. Setting _ProjectHierarchy to: ', this.projectAndWorkspaceScope.projectOID);
          }
          this.analyticsQuery.scope('_ProjectHierarchy', this.projectAndWorkspaceScope.projectOID);
        } else {
          if (this.config.debug) {
            console.log('Project with no up or down scoping. Setting Project to: ', this.projectAndWorkspaceScope.projectOID);
          }
          this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOID);
        }
      } else if (((_ref = this.config.scopeData) != null ? _ref.ObjectID : void 0) != null) {
        scopeValue = this.config.scopeData.ObjectID;
        this.analyticsQuery.scope(this.config.scopeField, scopeValue);
      } else {
        scopeValue = this.config.scopeValue;
        this.analyticsQuery.scope(this.config.scopeField, scopeValue);
      }
      fields = ["ObjectID"];
      this.analyticsQuery.fields(fields);
      if (this.config.leafOnly) {
        this.analyticsQuery.leafOnly();
      }
      if (this.config.type != null) {
        this.analyticsQuery.type(this.config.type);
      }
      this.analyticsQuery.additionalCriteria(this.config.currentStatePredicate);
      this.analyticsQuery.additionalCriteria({
        __At: "current"
      });
      if (this.config.debug) {
        this.analyticsQuery.debug();
        console.log('Requesting current state data ...');
      }
      return this.analyticsQuery.getAll(_callback);
    };

    VisualizerBase.prototype.getAsOfISOString = function() {
      if (this.config.asOf != null) {
        return this.asOfISOString = new Time(this.config.asOf, 'millisecond').getISOStringInTZ(this.config.lumenizeCalculatorConfig.tz);
      } else {
        return this.asOfISOString = Time.getISOStringFromJSDate();
      }
    };

    VisualizerBase.prototype.onSnapshotsReceieved = function(snapshots, startOn, endBefore, queryInstance) {
      var asOfISOString;
      if (queryInstance == null) {
        queryInstance = null;
      }
      if (this.config.trace) {
        console.log('in VisualizerBase.onSnapshotsReceieved');
      }
      if (snapshots.length > 0 && (new Time(endBefore, Time.MILLISECOND, this.config.tz).getJSDate('GMT').getTime() - new Time(startOn, Time.MILLISECOND, this.config.tz).getJSDate('GMT').getTime()) > 5 * 60 * 1000) {
        this.dirty = true;
      } else {
        this.dirty = false;
      }
      this.upToDateISOString = endBefore;
      this.deriveFieldsOnSnapshots(snapshots);
      asOfISOString = this.getAsOfISOString();
      if (asOfISOString < endBefore) {
        endBefore = asOfISOString;
      }
      this.updateCalculator(snapshots, startOn, endBefore);
      if ((this.config.asOf != null) && this.upToDateISOString < this.config.asOf) {
        this.fetchPending = false;
      } else {
        if (this.analyticsQuery.hasMorePages()) {
          this.fetchPending = true;
        } else {
          this.fetchPending = false;
        }
      }
      this.updateVisualization();
      if (!((this.config.asOf != null) && this.upToDateISOString < this.config.asOf)) {
        if (this.analyticsQuery.hasMorePages()) {
          return this.onNewDataAvailable();
        } else {
          return this.newDataExpected(void 0, this.config.refreshIntervalMilliseconds);
        }
      }
    };

    VisualizerBase.prototype.newDataExpected = function(paddingDelay, etlDelay) {
      var delay;
      if (paddingDelay == null) {
        paddingDelay = 30 * 1000;
      }
      if (etlDelay == null) {
        etlDelay = 30 * 60 * 1000;
      }
      if (this.config.trace) {
        console.log('in VisualizerBase.newDataExpected');
      }
      delay = etlDelay + paddingDelay;
      if (this.timeoutHandle != null) {
        clearTimeout(this.timeoutHandle);
      }
      return this.timeoutHandle = setTimeout(this.onConfigOrScopeUpdated, delay);
    };

    VisualizerBase.prototype.removeFromCacheAndRecalculate = function() {
      if (this.config.trace) {
        console.log('in VisualizerBase.removeFromCacheAndRecalculate');
      }
      this.upToDateISOString = null;
      this.cache.removeItem(this.getHashForCache());
      return this.onConfigOrScopeUpdated();
    };

    VisualizerBase.prototype.updateCalculator = function() {
      var endBefore, rest, savedState, snapshots, startOn, _ref;
      snapshots = arguments[0], startOn = arguments[1], endBefore = arguments[2], rest = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      /*
      @method updateCalculator
        Allows you to incrementally add snapshots to this calculator. It will also update the cache.
      @param {Object[]} snapshots An array of temporal data model snapshots.
      @param {String} startOn A ISOString (e.g. '2012-01-01T12:34:56.789Z') indicating the time start of the period of
        interest. On the second through nth call, this must equal the previous endBefore.
      @param {String} endBefore A ISOString (e.g. '2012-01-01T12:34:56.789Z') indicating the moment just past the time
        period of interest. This should be the ETLDate from the results of your query to the Lookback API.
      */

      if (this.config.trace) {
        console.log('in VisualizerBase.updateCalculator');
      }
      (_ref = this.lumenizeCalculator).addSnapshots.apply(_ref, [snapshots, startOn, endBefore].concat(__slice.call(rest)));
      return savedState = this.lumenizeCalculator.getStateForSaving();
    };

    VisualizerBase.prototype.initialize = function() {
      this.dirty = true;
      this.virgin = true;
      if (this.config.trace) {
        console.log('in VisualizerBase.initialize');
      }
      if (this.config.lumenizeCalculatorConfig == null) {
        this.config.lumenizeCalculatorConfig = {};
      }
      this.config.lumenizeCalculatorConfig.workDays = this.workspaceConfiguration.WorkDays;
      if (this.userConfig.tz != null) {
        return this.config.lumenizeCalculatorConfig.tz = this.userConfig.tz;
      } else {
        this.config.tz = this.workspaceConfiguration.TimeZone;
        return this.config.lumenizeCalculatorConfig.tz = this.workspaceConfiguration.TimeZone;
      }
    };

    VisualizerBase.prototype.deriveFieldsOnSnapshots = function(snapshots) {
      if (this.config.trace) {
        console.log('in VisualizerBase.deriveFieldsOnSnapshots');
      }
      if (this.config.deriveFieldsOnSnapshotsConfig != null) {
        return Lumenize.deriveFields(snapshots, this.config.deriveFieldsOnSnapshotsConfig);
      }
    };

    VisualizerBase.prototype.createVisualization = function() {
      if (this.config.trace) {
        console.log('in VisualizerBase.createVisualization. @dirty: ', this.dirty);
      }
      this.updateVisualizationData();
      return this.createVisualizationCB(this.visualizationData);
    };

    VisualizerBase.prototype.updateVisualization = function() {
      if (this.config.trace) {
        console.log('in VisualizerBase.updateVisualization. @dirty: ', this.dirty);
      }
      this.updateVisualizationData();
      if (this.dirty || this.virgin) {
        this.dirty = false;
        this.virgin = false;
        return this.createVisualizationCB(this.visualizationData);
      }
    };

    VisualizerBase.prototype.onNewDataAvailable = function() {
      if (this.config.trace) {
        console.log('in VisualizerBase.onNewDataAvailable');
      }
      this.fetchPending = true;
      return this.analyticsQuery.getPage(this.onSnapshotsReceieved);
    };

    VisualizerBase.prototype.updateVisualizationData = function() {
      if (this.config.trace) {
        return console.log('in VisualizerBase.updateVisualizationData');
      }
    };

    VisualizerBase.prototype.getHashForCache = function() {
      if (this.config.trace) {
        return console.log('in VisualizerBase.getHashForCache');
      }
    };

    return VisualizerBase;

  })();

  this.VisualizerBase = VisualizerBase;

}).call(this);

</script>
        
<script type="text/javascript">
// Generated by CoffeeScript 1.6.3
(function() {
  var TIPVisualizer, lumenize, utils, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils;

  TIPVisualizer = (function(_super) {
    __extends(TIPVisualizer, _super);

    function TIPVisualizer() {
      this.onNewDataAvailable = __bind(this.onNewDataAvailable, this);
      _ref = TIPVisualizer.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    */


    TIPVisualizer.prototype.initialize = function() {
      var field, s, trackLastValueForTheseFields, _i, _len, _ref1, _ref2;
      if (this.config.trace) {
        console.log('in TIPVisualizer.initialize');
      }
      TIPVisualizer.__super__.initialize.call(this);
      this.config.toolTipFieldNames = [];
      _ref1 = this.config.showTheseFieldsInToolTip;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        s = _ref1[_i];
        if (utils.type(s) === 'string') {
          field = s;
        } else {
          field = s.field;
        }
        this.config.toolTipFieldNames.push(field);
      }
      trackLastValueForTheseFields = ['_ValidTo'].concat(this.config.toolTipFieldNames);
      if (_ref2 = this.config.radiusField.field, __indexOf.call(trackLastValueForTheseFields, _ref2) < 0) {
        trackLastValueForTheseFields.push(this.config.radiusField.field);
      }
      this.config.lumenizeCalculatorConfig.trackLastValueForTheseFields = trackLastValueForTheseFields;
      this.config.lumenizeCalculatorConfig.granularity = 'hour';
      this.config.lumenizeCalculatorConfig.workDayStartOn = this.config.workDayStartOn;
      this.config.lumenizeCalculatorConfig.workDayEndBefore = this.config.workDayEndBefore;
      this.config.lumenizeCalculatorConfig.holidays = this.config.holidays;
      this.config.lumenizeCalculatorConfig.workDays = this.config.workDays;
      return this.LumenizeCalculatorClass = lumenize.TimeInStateCalculator;
    };

    TIPVisualizer.prototype.onNewDataAvailable = function() {
      var queryConfig;
      if (this.config.trace) {
        console.log('in TIPVisualizer.onNewDataAvailable');
      }
      queryConfig = {
        'X-RallyIntegrationName': 'TIP Chart (prototype)',
        'X-RallyIntegrationVendor': 'Rally Red Pill',
        'X-RallyIntegrationVersion': '0.2.0',
        workspaceOID: this.projectAndWorkspaceScope.workspaceOID
      };
      if (this.upToDateISOString == null) {
        this.upToDateISOString = '2011-12-01T00:00:00.000Z';
      }
      this.analyticsQuery = new TimeInStateAnalyticsQuery(queryConfig, this.upToDateISOString, this.config.statePredicate);
      if (this.projectAndWorkspaceScope.projectScopingUp) {
        if (this.config.debug) {
          console.log('Project scoping up. OIDs in scope: ', this.projectAndWorkspaceScope.projectOIDsInScope);
        }
        this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOIDsInScope);
      } else if (this.projectAndWorkspaceScope.projectScopingDown) {
        if (this.config.debug) {
          console.log('Project scoping down. Setting _ProjectHierarchy to: ', this.projectAndWorkspaceScope.projectOID);
        }
        this.analyticsQuery.scope('_ProjectHierarchy', this.projectAndWorkspaceScope.projectOID);
      } else {
        if (this.config.debug) {
          console.log('Project with no up or down scoping. Setting Project to: ', this.projectAndWorkspaceScope.projectOID);
        }
        this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOID);
      }
      this.analyticsQuery.type(this.config.type).fields(this.config.toolTipFieldNames);
      if (this.config.leafOnly) {
        this.analyticsQuery.leafOnly();
      }
      if (this.config.asOf != null) {
        this.analyticsQuery.additionalCriteria({
          _ValidFrom: {
            $lt: this.getAsOfISOString()
          }
        });
      }
      if (this.config.debug) {
        this.analyticsQuery.debug();
        console.log('Requesting data...');
      }
      this.fetchPending = true;
      return this.analyticsQuery.getPage(this.onSnapshotsReceieved);
    };

    TIPVisualizer.prototype.getHashForCache = function() {
      var hashObject, hashString, out, salt, userConfig;
      if (this.config.trace) {
        console.log('in TIPVisualizer.getHashForCache');
      }
      hashObject = {};
      userConfig = utils.clone(this.userConfig);
      delete userConfig.debug;
      delete userConfig.trace;
      delete userConfig.daysToShow;
      delete userConfig.showStillInProgress;
      hashObject.userConfig = userConfig;
      hashObject.projectAndWorkspaceScope = this.projectAndWorkspaceScope;
      hashObject.workspaceConfiguration = this.workspaceConfiguration;
      salt = 'TIP v0.2.95';
      hashString = JSON.stringify(hashObject);
      out = md5(hashString + salt);
      return out;
    };

    TIPVisualizer.prototype.updateVisualizationData = function() {
      var asOfMilliseconds, b, bucketSize, buckets, calculatorResults, chartMax, clipped, endBeforeInMinutes, histogramCategories, histogramData, histogramResults, inProcessItems, jsDateMilliseconds, millisecondsToShow, notInProcessItems, row, series, startMilliseconds, startOnInMinutes, valueMax, workHours, workMinutes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref1, _ref2;
      if (this.config.trace) {
        console.log('in TIPVisualizer.updateVisualizationData');
      }
      calculatorResults = this.lumenizeCalculator.getResults();
      if (calculatorResults.length === 0) {
        if (this.config.debug) {
          console.log('No calculatorResults.');
        }
        if (this.fetchPending) {
          if (this.config.debug) {
            console.log('fetchPending is true so returning with visualizationData = null.');
          }
          this.visualizationData = null;
          return;
        } else {
          series = [];
          if (this.config.debug) {
            console.log('fetchPending is false so filling in with blanks');
          }
        }
      } else {
        this.virgin = false;
        inProcessItems = [];
        notInProcessItems = [];
        if (this.config.asOf != null) {
          asOfMilliseconds = new lumenize.Time(this.config.asOf, 'millisecond', this.config.lumenizeCalculatorConfig.tz).getJSDate(this.config.lumenizeCalculatorConfig.tz).getTime();
        } else {
          asOfMilliseconds = new Date().getTime();
        }
        millisecondsToShow = this.userConfig.daysToShow * 1000 * 60 * 60 * 24;
        startMilliseconds = asOfMilliseconds - millisecondsToShow;
        for (_i = 0, _len = calculatorResults.length; _i < _len; _i++) {
          row = calculatorResults[_i];
          jsDateMilliseconds = new lumenize.Time(row._ValidTo_lastValue, 'millisecond', this.config.lumenizeCalculatorConfig.tz).getJSDate(this.config.lumenizeCalculatorConfig.tz).getTime();
          if (jsDateMilliseconds > asOfMilliseconds) {
            row.x = asOfMilliseconds;
          } else {
            row.x = jsDateMilliseconds;
          }
          row.x -= Math.random() * 1000 * 60 * 60 * 24;
          if (this.config.radiusField != null) {
            row.marker = {
              radius: this.config.radiusField.f(row[this.config.radiusField.field + "_lastValue"])
            };
          }
          if (jsDateMilliseconds > startMilliseconds) {
            if (jsDateMilliseconds < asOfMilliseconds) {
              notInProcessItems.push(row);
            } else {
              inProcessItems.push(row);
            }
          }
        }
        startOnInMinutes = this.config.workDayStartOn.hour * 60;
        if ((_ref1 = this.config.workDayStartOn) != null ? _ref1.minute : void 0) {
          startOnInMinutes += this.config.workDayStartOn.minute;
        }
        endBeforeInMinutes = this.config.workDayEndBefore.hour * 60;
        if ((_ref2 = this.config.workDayEndBefore) != null ? _ref2.minute : void 0) {
          endBeforeInMinutes += this.config.workDayEndBefore.minute;
        }
        if (startOnInMinutes < endBeforeInMinutes) {
          workMinutes = endBeforeInMinutes - startOnInMinutes;
        } else {
          workMinutes = 24 * 60 - startOnInMinutes;
          workMinutes += endBeforeInMinutes;
        }
        workHours = workMinutes / 60;
        for (_j = 0, _len1 = inProcessItems.length; _j < _len1; _j++) {
          row = inProcessItems[_j];
          row.days = row.ticks / workHours;
        }
        for (_k = 0, _len2 = notInProcessItems.length; _k < _len2; _k++) {
          row = notInProcessItems[_k];
          row.days = row.ticks / workHours;
        }
      }
      histogramResults = lumenize.histogram(notInProcessItems, 'days');
      if (histogramResults == null) {
        if (this.config.debug) {
          console.log('No histogramResults. Returning.');
        }
        return;
      }
      buckets = histogramResults.buckets, chartMax = histogramResults.chartMax, valueMax = histogramResults.valueMax, bucketSize = histogramResults.bucketSize, clipped = histogramResults.clipped;
      for (_l = 0, _len3 = notInProcessItems.length; _l < _len3; _l++) {
        row = notInProcessItems[_l];
        row.y = row.clippedChartValue;
      }
      for (_m = 0, _len4 = inProcessItems.length; _m < _len4; _m++) {
        row = inProcessItems[_m];
        if (row.days > chartMax) {
          row.y = chartMax;
        } else {
          row.y = row.days;
        }
      }
      histogramCategories = [];
      histogramData = [];
      for (_n = 0, _len5 = buckets.length; _n < _len5; _n++) {
        b = buckets[_n];
        histogramCategories.push(b.label);
        histogramData.push(b.count);
      }
      series = [
        {
          name: 'Not in Process',
          data: notInProcessItems
        }, {
          name: 'In Process',
          data: inProcessItems
        }, {
          name: 'Percentile',
          data: [],
          yAxis: 1,
          showInLegend: false
        }
      ];
      return this.visualizationData = {
        series: series,
        histogramResults: histogramResults,
        histogramCategories: histogramCategories,
        histogramData: histogramData,
        startMilliseconds: startMilliseconds,
        asOfMilliseconds: asOfMilliseconds
      };
    };

    return TIPVisualizer;

  })(VisualizerBase);

  this.TIPVisualizer = TIPVisualizer;

}).call(this);

</script>

        <script type="text/javascript">
            (function() {

                var charts = {};
                var visualizer;

                createVisualization = function(visualizationData) {

                  if (typeof visualizationData !== "undefined" && visualizationData !== null) {

                    var series = visualizationData.series;
                    var histogramResults = visualizationData.histogramResults;
                    var startMilliseconds = visualizationData.startMilliseconds
                    var asOfMilliseconds = visualizationData.asOfMilliseconds

                    var histogramCategories = visualizationData.histogramCategories;
                    var histogramData = visualizationData.histogramData;

                    var bucketSize = histogramResults.bucketSize;
                    var chartMax = histogramResults.chartMax;
                    var buckets = histogramResults.buckets;
                    var clipped = histogramResults.clipped;
                    var valueMax = histogramResults.valueMax;

                    charts.scatterChart = new Highcharts.Chart({
                      chart: {
                         renderTo: 'scatter-container',
                         defaultSeriesType: 'scatter',
                         zoomType: 'x',
                         marginTop: 80
                      },
                      legend: {
                         enabled: true,
                         floating: true,
                         align: 'center',
                         verticalAlign: 'top',
                         y: 37
                      },
                      credits: {
                         enabled: false
                      },
                      title: {
                         text: 'Time In Process'
                      },
                      subtitle: {
                         text: userConfig.subTitle
                      },
                      xAxis: {
                         startOnTick: false,
                         tickmarkPlacement: 'on',
                         title: {
                             enabled: false
                         },
                         type: 'datetime',
                         min: startMilliseconds,
                         max: asOfMilliseconds
                      },
                      yAxis: [
                         {
                             title: {
                                 text: 'Time In Process (Work Days)'
                             },
                             opposite: false,
                             endOnTick: false,
                             tickInterval: bucketSize,
                             labels: {
                               formatter: function() {
                                   if (this.value !== 0) {
                                     if (this.value == chartMax) {
                                       if (clipped) {
                                         return '' + valueMax + '*';
                                       } else {
                                         return chartMax;
                                       }
                                     } else {
                                       return this.value;
                                     }
                                   }
                                 }

                             },
                             min: 0,
                             max: chartMax
                         },
                         {
                             title: {
                                 text: null
                             },
                             opposite: true,
                             // endOnTick: true,
                             tickInterval: 1,
                             labels: {
                                 formatter: function() {
                                    if (this.value !== 0) {
                                      return Highcharts.numberFormat(buckets[this.value - 1].percentile * 100, 1) + "%";
                                    } else {
                                      return "0.0%";
                                    }
                                  }
                             },
                             min: 0,
                             max: buckets.length
                         }

                      ],
                      tooltip: {
                         formatter: function() {
                             var point = this.point;
                             tooltip = 'ObjectID: ' + point.ObjectID + '<br />';  // !TODO: Upgrade to link to revisions page in Rally
                             tooltip += this.series.name + ': <b>' + Highcharts.numberFormat(point.days, 1) + '</b> work days';
                             var t, _i, _len, _ref, f, field, as;
                             _ref = userConfig.showTheseFieldsInToolTip;
                             for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                t = _ref[_i];
                                if (typeof t === 'string') {
                                  field = t;
                                  f = function(value) {
                                    return value;
                                  };
                                  as = t;
                                } else {
                                  field = t.field;
                                  if (t.f != null) {
                                    f = t.f;
                                  } else {
                                    f = function(value) {
                                      return value;
                                    };
                                  }
                                  if (t.as != null) {
                                    as = t.as;
                                  } else {
                                    as = t.field;
                                  }
                                }
                                tooltip += '<br />' + as + ': ' + f(point[field + "_lastValue"]);
                             }
                             return tooltip;
                         }
                      },
                      plotOptions: {
                          scatter: {
                             marker: {
                                states: {
                                   hover: {
                                      enabled: false
                                   }
                                }
                             }
                          },
                          series: {
                              events: {
                                  legendItemClick: function(event) {
                                      if (this.index == 0) {
                                          if (!this.visible) {
                                             this.chart.xAxis[0].setExtremes(startMilliseconds, asOfMilliseconds, false);
                                          } else {
                                             this.chart.xAxis[0].setExtremes(asOfMilliseconds - 24 * 60 * 60 * 1000, asOfMilliseconds, false);
                                          };
                                          this.chart.redraw();
                                      };
                                      return true;
                                  }
                              }
                          }
                      },
                      series: series
                    }, function(chart) {
                        if (clipped) {
                          chart.renderer.text('* non-linear', 57, 55).add();
                        };
                        if (series[0].data.length == 0) {
                          chart.renderer.text('No matching data for this project and scope.', chart.chartWidth / 2 - 127, chart.chartHeight / 2 - 100).add();
                        }
                    });  // end of scatterChart

                    charts.histogramChart = new Highcharts.Chart({
                   		chart: {
                   			renderTo: 'histogram-container',
                   			type: 'bar',
                   			marginTop: 80
                   		},
                       legend: {
                         enabled: false
                       },
                       credits: {
                           enabled: false
                       },
                   		title: {
                   			text: 'Histogram'
                   		},
                   		subtitle: {
                   			text: 'for Not In Process'
                   		},
                   		xAxis: [{ // mirror axis on right side
                   			opposite: false,
                   			reversed: false,
                   			categories: histogramCategories,
                   		}],
                   		yAxis: {
                   			title: {
                   				text: null
                   			},
                         labels: {
                   				formatter: function(){
                   					return Math.abs(this.value);
                   				}
                   			},
                   			min: 0
                   		},
                   		plotOptions: {
                   			series: {
                   				stacking: 'normal'
                   			}
                   		},
                   		tooltip: {
                   			formatter: function(){
                   				return '' + this.point.category +' work days: <b>' + Highcharts.numberFormat(Math.abs(this.point.y), 0) + '</b>';
                   			}
                   		},
                   		series: [{
                   			name: 'Time in process',
                   			data: histogramData
                   		}]
                   	}, function(chart) {
                   	     if (false) {
                            chart.renderer.text('* non-linear', 200, 65).add();
                          };
                    });  // end of histogramChart

                  } else {
                    // Put a spinner in the chart containers until first fetch returns
                    $('#scatter-container')
                      .html('<img height="20px" src="https://rally1.rallydev.com/slm/js-lib/ext/2.2/resources/images/default/grid/loading.gif"></img>')
                      .attr("style", "text-align:center");
                    $('#histogram-container')
                      .html('<img height="20px" src="https://rally1.rallydev.com/slm/js-lib/ext/2.2/resources/images/default/grid/loading.gif"></img>')
                      .attr("style", "text-align:center");
                  };  // end of if visualizationData?

                };  // end of createVisualization


                $(document).ready(function() {
                  visualizer = new TIPVisualizer(charts, userConfig, createVisualization);
                });

            })();


        </script>


    </head>
    <body>

        <!-- 3. Add the containers -->
        <table cellpading="0px" cellspacing="0px" width="98%" height="98%">
          <tr>
            <td width="65%"><div id="scatter-container" style="width: 100%; height: 100%; margin: 0 auto"></div></td>
            <td width="35%"><div id="histogram-container" style="width: 100%; height: 100%; margin: 0 auto"></div></td>
          </tr>
        </table>

    </body>
</html>